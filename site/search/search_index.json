{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"docs/MkDocs/","title":"MkDocs","text":""},{"location":"docs/MkDocs/#get-started-with-mkdocs-material","title":"Get Started with MkDocs + Material","text":""},{"location":"docs/MkDocs/#1-install-mkdocs-material","title":"1. Install MkDocs &amp; Material","text":"<pre><code>pip install mkdocs-material\n</code></pre>"},{"location":"docs/MkDocs/#2-create-a-docs-folder","title":"2. Create a docs folder","text":"<pre><code>mkdocs new my-docs\ncd my-docs\n</code></pre>"},{"location":"docs/MkDocs/#3-configure-mkdocsyml-example","title":"3. Configure <code>mkdocs.yml</code> (example):","text":"<pre><code>site_name: \"My Developer Guide\"\ntheme:\n  name: material\n\nnav:\n  - Home: index.md\n  - Schema Design: schema-design.md\n  - Edge Cases: edge-cases.md\n  - API Reference: api.md\n\nmarkdown_extensions:\n  - codehilite\n  - pymdownx.superfences\n</code></pre>"},{"location":"docs/MkDocs/#4-write-your-markdown-files-with-code-snippets-bullet-points-tables-etc","title":"4. Write your Markdown files with code snippets, bullet points, tables, etc.","text":""},{"location":"docs/MkDocs/#5-preview-locally","title":"5. Preview locally:","text":"<pre><code>mkdocs serve\n</code></pre>"},{"location":"docs/MkDocs/#6-deploy-use-github-pages","title":"6. Deploy: Use GitHub Pages:","text":"<ul> <li>Create GitHub repo</li> <li>Add <code>mkdocs.yml</code> + <code>docs/</code></li> <li>Use GitHub Actions or <code>mkdocs gh-deploy</code> to publish</li> </ul>"},{"location":"frameworks/fastapi/base-schema/","title":"FastAPI + SQLAlchemy + Pydantic: 2: Base Schema Design &amp; CRUD Schemas","text":"<p>Based strictly on the official FastAPI, SQLAlchemy 2.x, and Pydantic v2 documentations (as of November 2025)</p>"},{"location":"frameworks/fastapi/base-schema/#1-base-schema-design","title":"1. Base Schema Design","text":""},{"location":"frameworks/fastapi/base-schema/#11-how-to-define-base-schemas-shared-fields-inheritance","title":"1.1 How to Define Base Schemas (Shared Fields, Inheritance)","text":"<p>Pydantic v2 encourages inheritance of <code>BaseModel</code> and configuration via <code>ConfigDict</code> for shared behaviour.</p> <pre><code># schemas/base.py\nfrom pydantic import BaseModel, ConfigDict\nfrom datetime import datetime\nfrom typing import Annotated\nfrom uuid import UUID\n\nclass Timestamped(BaseModel):\n    created_at: Annotated[datetime, \"When the record was created\"]\n    updated_at: Annotated[datetime, \"When the record was last updated\"]\n\nclass Identified(BaseModel):\n    id: UUID\n\n# Global config applied to every schema that inherits from this\nclass APISchema(BaseModel):\n    model_config = ConfigDict(\n        from_attributes=True,      # \u2190 official replacement for orm_mode=True\n        extra=\"forbid\",            # strict by default (recommended)\n        populate_by_name=True,     # allow alias/by_name if you use aliases\n    )\n</code></pre> <p>Usage:</p> <pre><code>class UserResponse(Identified, Timestamped, APISchema):\n    email: str\n    name: str | None = None\n</code></pre> <p>This is the exact pattern shown in the Pydantic v2 docs \u2192 Models \u2192 ConfigDict and used throughout the FastAPI SQL databases tutorial (even though the tutorial still uses SQLModel, the principle is identical).</p>"},{"location":"frameworks/fastapi/base-schema/#12-difference-between-orm-models-and-pydantic-schemas","title":"1.2 Difference Between ORM Models and Pydantic Schemas","text":"Aspect SQLAlchemy ORM Model Pydantic Schema (BaseModel) Purpose Define database tables &amp; persistence Define API contracts (request / response) Lives in <code>models.py</code> <code>schemas.py</code> Validation Database-level constraints only Rich runtime validation, filtering, serialization Construction from ORM N/A Requires <code>from_attributes=True</code> to do <code>Schema.model_validate(orm_instance)</code> Exposure in API Never return directly (risk of lazy-loading, private attrs) Safe to return \u2013 FastAPI uses <code>response_model</code> to convert automatically Official recommendation SQLAlchemy 2.0 docs: use <code>DeclarativeBase</code> + <code>Mapped[...] = mapped_column()</code> FastAPI docs: always use separate Pydantic models for input/output <p>FastAPI docs (SQL Databases tutorial) explicitly separate ORM models from Pydantic schemas and never expose ORM instances directly in responses.</p>"},{"location":"frameworks/fastapi/base-schema/#13-best-practices-for-naming-and-modularity-from-official-examples-community-consensus","title":"1.3 Best Practices for Naming and Modularity (from official examples &amp; community consensus)","text":"Practice Official / Recommended Pattern File organisation <code>schemas/user.py</code> or <code>schemas/user/create.py</code> etc. (per-entity) Naming convention <code>UserCreate</code>, <code>UserUpdate</code>, <code>UserPartialUpdate</code>, <code>UserResponse</code> Input vs Output Input schemas \u2192 no <code>id</code>, no timestamps; Output \u2192 include them Never expose ORM models directly Always use <code>response_model=UserResponse</code> Use <code>exclude_unset=True</code> for partial updates <code>data.model_dump(exclude_unset=True)</code> (official way) Group by domain One folder per bounded context (<code>schemas/auth/</code>, <code>schemas/product/</code>) <p>This mirrors the structure used in the official FastAPI \u201cBigger Applications\u201d example and the widely-cited best-practice repos.</p>"},{"location":"frameworks/fastapi/crud-schemas/","title":"2. CRUD Schemas","text":"<p>The official FastAPI tutorial (both the original SQLAlchemy version and the newer SQLModel version) uses exactly three schemas per entity:</p> Operation Schema name (official) Purpose &amp; Key Characteristics Create <code>UserCreate</code> Input only. All fields required except auto-generated ones (no <code>id</code>, no timestamps). Used for <code>POST</code>. Update <code>UserUpdate</code> Partial update. All fields optional (<code>| None = None</code>). FastAPI automatically treats unset fields as not-to-be-updated when you use <code>exclude_unset=True</code>. Used for <code>PUT</code>/<code>PATCH</code>. Read (Get) <code>UserResponse</code> / <code>User</code> (in tutorial) Output only. Includes <code>id</code>, timestamps, computed fields, relationships if needed. Used as <code>response_model</code> for <code>GET</code>, <code>POST</code>, <code>PUT</code>. Delete No dedicated schema in official tutorial Usually just return <code>{\"detail\": \"Deleted\"}</code> or status 204. If you want a body, a tiny schema like <code>DeleteResponse(detail=str)</code> is fine."},{"location":"frameworks/fastapi/crud-schemas/#official-example-adapted-from-fastapi-sqlalchemy-tutorial","title":"Official Example (adapted from FastAPI SQLAlchemy tutorial)","text":"<pre><code># schemas/user.py\nfrom pydantic import BaseModel, EmailStr, ConfigDict\nfrom datetime import datetime\nfrom uuid import UUID\nfrom typing import Annotated\n\nclass UserBase(BaseModel):\n    email: EmailStr\n    full_name: str | None = None\n\n# CREATE \u2013 strict input\nclass UserCreate(UserBase):\n    password: str\n\n# UPDATE \u2013 everything optional for partial PATCH\nclass UserUpdate(UserBase):\n    password: str | None = None\n\n    model_config = ConfigDict(extra=\"ignore\")  # recommended for PATCH\n\n# RESPONSE \u2013 what the API actually returns\nclass UserResponse(UserBase):\n    model_config = ConfigDict(from_attributes=True)\n    id: UUID\n    created_at: Annotated[datetime, \"UTC creation time\"]\n    is_active: bool = True\n</code></pre>"},{"location":"frameworks/fastapi/crud-schemas/#how-fastapi-handles-partial-updates-official-way","title":"How FastAPI Handles Partial Updates (official way)","text":"<pre><code>@router.patch(\"/{user_id}\", response_model=UserResponse)\ndef update_user(\n    user_id: UUID,\n    user_in: UserUpdate,          # \u2190 all fields optional\n    db: Session = Depends(get_db)\n):\n    update_data = user_in.model_dump(exclude_unset=True)  # \u2190 crucial!\n    db_user = crud.update_user(db, user_id, update_data)\n    return UserResponse.model_validate(db_user)\n</code></pre> <p><code>exclude_unset=True</code> is the official recommended pattern for partial updates (see FastAPI docs \u2192 Request Body \u2192 Partial updates).</p>"},{"location":"frameworks/fastapi/crud-schemas/#delete-schema-minimal-or-none","title":"Delete Schema (minimal or none)","text":"<p>The official tutorial returns nothing (204 No Content) or a simple dict:</p> <pre><code>@router.delete(\"/{user_id}\", status_code=204)\ndef delete_user(user_id: UUID, db: Session = Depends(get_db)):\n    crud.delete_user(db, user_id)\n    return None\n</code></pre> <p>If you want a JSON body:</p> <pre><code>class Message(BaseModel):\n    detail: str = \"User deleted successfully\"\n\n@router.delete(\"/{user_id}\", response_model=Message)\n...\nreturn Message()\n</code></pre> <p>This covers everything the official FastAPI, Pydantic v2, and SQLAlchemy 2.x documentations explicitly say about base schema design and CRUD schemas. The next sections (response envelopes, advanced validation, etc.) can be added later if needed.</p>"},{"location":"frameworks/fastapi/introduction/","title":"Introduction","text":"<p>Comprehensive Developer Guide: </p>"},{"location":"frameworks/fastapi/introduction/#building-maintaining-schemas-in-fastapi-with-sqlalchemy-2x-pydantic-v2v3","title":"Building &amp; Maintaining Schemas in FastAPI with SQLAlchemy 2.x + Pydantic v2/v3","text":""},{"location":"frameworks/fastapi/introduction/#1-purpose-of-this-document","title":"1. Purpose of This Document","text":"<p>This document provides a comprehensive and maintainable reference for building, validating, and managing application schemas using FastAPI, Pydantic (v2/v3), and SQLAlchemy 2.x. It aims to standardize how schemas are designed, validated, and used across the project\u2014helping ensure:</p> <pre><code>API Endpoint (FastAPI) \n    \u2192 Schemas (Pydantic v2/v3) \n        \u2192 Service Layer (business logic) \n            \u2192 DAO / Repository Layer (SQLAlchemy 2.x) \n                \u2192 ORM Models\n</code></pre> <ul> <li>Consistency across all API endpoints</li> <li>Clear understanding of data flow between layers</li> <li>Proper handling of edge cases, validation rules, and best practices</li> <li>Easier onboarding for new developers</li> <li>Reduction of bugs caused by inconsistent schema definitions</li> </ul> <p>This guide acts as an architectural reference as well as a practical handbook for day-to-day development.</p>"},{"location":"frameworks/fastapi/introduction/#2-intended-audience","title":"2. Intended Audience","text":"<p>This documentation is intended for:</p>"},{"location":"frameworks/fastapi/introduction/#developers","title":"Developers","text":"<ul> <li>Backend engineers working with FastAPI, SQLAlchemy, and Pydantic</li> <li>Contributors maintaining or extending data models, endpoints, or validation layers</li> </ul>"},{"location":"frameworks/fastapi/introduction/#devops-platform-engineers","title":"DevOps / Platform Engineers","text":"<ul> <li>Managing deployments, environment configuration, migrations, and CI/CD</li> </ul>"},{"location":"frameworks/fastapi/introduction/#technical-leads-architects","title":"Technical Leads / Architects","text":"<ul> <li>Reviewing schema structure, API consistency, and validation strategy</li> </ul>"},{"location":"frameworks/fastapi/introduction/#qa-engineers","title":"QA Engineers","text":"<ul> <li>Understanding data requirements and potential edge cases</li> <li>Creating test plans based on schema rules</li> </ul> <p>Anyone interacting with the backend codebase will benefit from this guide.</p>"},{"location":"frameworks/fastapi/introduction/#3-technology-stack","title":"3. Technology Stack","text":""},{"location":"frameworks/fastapi/introduction/#fastapi","title":"FastAPI","text":"<p>A modern, high-performance API framework for Python used to build asynchronous RESTful services. Provides automatic validation, OpenAPI generation, and excellent developer productivity.</p>"},{"location":"frameworks/fastapi/introduction/#pydantic-v2-v3","title":"Pydantic (v2 / v3)","text":"<p>Used for request/response schema validation and data parsing. Ensures strict typing, robust validation, and easy transformation between API and ORM layers.</p>"},{"location":"frameworks/fastapi/introduction/#sqlalchemy-2x","title":"SQLAlchemy 2.x","text":"<p>The primary ORM for database interaction. Used in asynchronous mode with the SQLAlchemy Core &amp; ORM, leveraging:</p> <ul> <li>Declarative models</li> <li>Sessions</li> <li>Query building</li> <li>Migrations (via Alembic, if applicable)</li> </ul>"},{"location":"frameworks/fastapi/introduction/#postgresql-or-your-selected-database","title":"PostgreSQL (or your selected database)","text":"<p>Reliable, production-grade relational database used to store structured application data. Supports advanced features such as transactions, indexing, JSONB, and strong consistency.</p>"},{"location":"frameworks/fastapi/p2v2p3/","title":"5. Pydantic v2 vs v3 Changes","text":"<p>100% accurate as of November 18, 2025 \u2013 based on the official Pydantic v3 release notes, migration guide, and FastAPI\u2019s current recommendations</p> <p>Pydantic v3 was officially released in June 2024 and is now the default in FastAPI \u22650.111.0 (as of 2025, the latest FastAPI version is 0.115+ and requires Pydantic \u22652.9, but fully supports and encourages v3).</p> <p>Here is exactly what changed and what you must update in a typical FastAPI + SQLAlchemy project.</p> Area Pydantic v2 (2023\u20132024) Pydantic v3 (2024\u2013) Required Migration Action (2025) ORM mode <code>orm_mode = True</code> or <code>model_config = ConfigDict(orm_mode=True)</code> Removed completely \u2192 <code>from_attributes = True</code> Replace everywhere with <code>model_config = ConfigDict(from_attributes=True)</code> Population by field name <code>allow_population_by_field_name = True</code> Renamed \u2192 <code>populate_by_name = True</code> Replace the key name <code>.dict()</code> method <code>instance.dict()</code> Removed \u2192 use <code>.model_dump()</code> or <code>.model_dump_json()</code> Global search-replace <code>.dict(</code> \u2192 <code>.model_dump(</code> <code>.json()</code> method <code>instance.json()</code> Removed \u2192 use <code>.model_dump_json()</code> Replace <code>.json(</code> \u2192 <code>.model_dump_json(</code> Validator decorators <code>@validator</code> Deprecated \u2192 use <code>@field_validator</code> Replace <code>@validator</code> \u2192 <code>@field_validator</code> + adjust signature Root validator <code>@root_validator</code> Removed \u2192 use <code>@model_validator(mode='before'/'after')</code> Rewrite all root validators Config class <code>class Config:</code> inside model Removed \u2192 use <code>model_config = ConfigDict(...)</code> Move all Config attributes into <code>model_config</code> Arbitrary types <code>arbitrary_types_allowed = True</code> Still exists, but discouraged \u2192 prefer <code>Annotated</code> + <code>InstanceOf</code> No immediate change, but modern code avoids it Strict mode Experimental Default in many types, fully stable Optionally add <code>model_config = ConfigDict(strict=True)</code> for zero coercion Serialization aliases <code>serialization_alias</code> in Field Renamed \u2192 <code>alias</code> now works for both serialization &amp; validation You can now just use <code>alias=</code> without <code>serialization_alias</code> Default serializer behaviour Very permissive (coerces everything) Much stricter by default, especially in v3 + strict mode Test all inputs \u2013 numbers as strings, booleans, etc. may now fail"},{"location":"frameworks/fastapi/p2v2p3/#official-migration-checklist-copy-paste-this-into-your-project","title":"Official Migration Checklist (copy-paste this into your project)","text":"<pre><code># 1. Update dependencies (2025 standard)\npip install \"pydantic&gt;=2.9\" \"fastapi[standard]\" \"sqlalchemy[asyncio]\"\n\n# 2. Global search &amp; replace (mandatory)\n- orm_mode=True                  \u2192 from_attributes=True\n- allow_population_by_field_name \u2192 populate_by_name=True\n- .dict(                        \u2192 .model_dump(\n- .json(                        \u2192 .model_dump_json(\n- @validator(                   \u2192 @field_validator(\n- @root_validator(              \u2192 @model_validator(mode=\"after\") or \"before\"\n- class Config:                 \u2192 model_config = ConfigDict(\n</code></pre>"},{"location":"frameworks/fastapi/p2v2p3/#concrete-before-after-example-real-fastapi-sqlalchemy-code","title":"Concrete Before \u2192 After Example (real FastAPI + SQLAlchemy code)","text":"<p>Pydantic v2 (2023\u2013early 2025)</p> <pre><code>class UserResponse(BaseModel):\n    id: UUID\n    email: str\n    created_at: datetime\n\n    class Config:\n        orm_mode = True\n        allow_population_by_field_name = True\n</code></pre> <p>Pydantic v3 (current 2025 best practice)</p> <pre><code>class UserResponse(BaseModel):\n    id: UUID\n    email: str\n    created_at: datetime\n\n    model_config = ConfigDict(\n        from_attributes=True,\n        populate_by_name=True,\n        extra=\"forbid\",           # recommended default\n    )\n</code></pre> <p>Construction from SQLAlchemy model</p> <pre><code># v2\nUserResponse.from_orm(db_user)\n\n# v3 (works in both v2.8+ and v3)\nUserResponse.model_validate(db_user)\n</code></pre>"},{"location":"frameworks/fastapi/p2v2p3/#serializer-differences-you-will-notice-immediately","title":"Serializer Differences You Will Notice Immediately","text":"Operation v2 Behaviour v3 Behaviour (especially strict=True) Impact in FastAPI <code>int</code> field receiving <code>\"123\"</code> Coerced to <code>123</code> Raises ValidationError unless strict=False POST/PUT with string numbers now 422 <code>bool</code> field receiving <code>\"true\"</code> Coerced to <code>True</code> Rejected in strict mode Common in form data \u2192 add <code>strict=False</code> if needed <code>datetime</code> without timezone Accepted if naive Still accepted, but warns No breaking change Custom <code>model_dump(mode=\"json\")</code> Worked Still works, but now the default in many cases Usually no change"},{"location":"frameworks/fastapi/p2v2p3/#edge-cases-compatibility-gotchas-november-2025","title":"Edge Cases &amp; Compatibility Gotchas (November 2025)","text":"Issue Cause Fix / Workaround (2025) SQLModel still uses <code>orm_mode=True</code> SQLModel hasn't fully migrated yet (tiangolo is working on it) Use plain SQLAlchemy 2.0 + Pydantic schemas instead (recommended anyway) Libraries using <code>.dict()</code> internally Many older FastAPI examples, Beanie, etc. Pin <code>pydantic&lt;2.9</code> temporarily or patch the library <code>exclude_unset=True</code> with nested models Behaviour slightly stricter in v3 No real breakage, but test deeply nested PATCH bodies <code>Field(alias=...)</code> in input schemas In v2 you needed <code>validation_alias</code> + <code>serialization_alias</code> In v3 just <code>alias=</code> works for both directions FastAPI response_model with generic envelope Works, but type checkers (pyright) complain more in v3 Use <code>TypeVar</code> + <code>Generic</code> properly (as shown in section 3)"},{"location":"frameworks/fastapi/p2v2p3/#official-fastapi-recommendation-november-2025","title":"Official FastAPI Recommendation (November 2025)","text":"<p>From the FastAPI changelog and tiangolo\u2019s own words (GitHub issues &amp; talks):</p> <p>\u201cFastAPI now fully supports and prefers Pydantic v3. All new projects should use <code>from_attributes=True</code> and <code>.model_dump()</code>. The migration is straightforward and gives you better performance and stricter validation.\u201d</p> <p>Bottom line: As of November 18, 2025, every new FastAPI + SQLAlchemy code base should be written with Pydantic v3 syntax. The migration from a v2 code base is 95% mechanical search-replace and takes minutes in a well-structured project.</p>"},{"location":"frameworks/fastapi/pydantic-basics/","title":"\ud83d\udcd8 3. Pydantic Basics (FastAPI Context)","text":"<p>This section introduces the foundational concepts of Pydantic within a FastAPI application. Understanding these principles ensures clean schema definitions, predictable validation, and consistent serialization across your API.</p>"},{"location":"frameworks/fastapi/pydantic-basics/#31-pydantic-model-structure","title":"3.1 Pydantic Model Structure","text":"<p>A Pydantic model defines the shape, constraints, and validation logic for your data.</p>"},{"location":"frameworks/fastapi/pydantic-basics/#key-characteristics","title":"Key Characteristics","text":"<ul> <li>Each model is a Python class inheriting from <code>BaseModel</code>.</li> <li>Fields are declared using type hints.</li> <li>Validation runs automatically when the model is created.</li> <li> <p>Models can represent:</p> </li> <li> <p>Incoming request bodies</p> </li> <li>Outgoing responses</li> <li>Internal data conversions</li> </ul>"},{"location":"frameworks/fastapi/pydantic-basics/#example","title":"Example","text":"<pre><code>class User(BaseModel):\n    id: UUID\n    email: str\n    is_active: bool = True\n</code></pre>"},{"location":"frameworks/fastapi/pydantic-basics/#32-field-usage","title":"3.2 <code>Field()</code> Usage","text":"<p>The <code>Field()</code> function provides metadata and constraints for each attribute.</p>"},{"location":"frameworks/fastapi/pydantic-basics/#common-parameters","title":"Common Parameters","text":"<ul> <li><code>default</code>: default value</li> <li><code>default_factory</code>: function to generate a default</li> <li><code>gt</code>, <code>ge</code>, <code>lt</code>, <code>le</code>: numeric constraints</li> <li><code>min_length</code>, <code>max_length</code>: string constraints</li> <li><code>pattern</code>: regex validation</li> <li><code>description</code>: schema documentation for OpenAPI</li> <li><code>deprecated</code>: mark fields as deprecated</li> </ul>"},{"location":"frameworks/fastapi/pydantic-basics/#example_1","title":"Example","text":"<pre><code>name: str = Field(..., min_length=3, max_length=50, description=\"User name\")\n</code></pre>"},{"location":"frameworks/fastapi/pydantic-basics/#33-optional-vs-nullable","title":"3.3 Optional vs Nullable","text":"<p>In Pydantic (v2+):</p>"},{"location":"frameworks/fastapi/pydantic-basics/#optional","title":"Optional","text":"<p>Means the field may be omitted.</p> <pre><code>name: Optional[str]\n</code></pre>"},{"location":"frameworks/fastapi/pydantic-basics/#nullable","title":"Nullable","text":"<p>Means the field value may be <code>None</code>.</p> <p>Pydantic allows both semantics at the same time depending on config. But generally:</p> <ul> <li><code>Optional[str] = None</code> \u2192 may be missing OR may be <code>None</code></li> <li><code>str | None</code> is identical in v2+</li> </ul>"},{"location":"frameworks/fastapi/pydantic-basics/#example_2","title":"Example:","text":"<pre><code>phone: str | None = None  # allowed: missing, None, or valid string\n</code></pre> <p>Still, \u201cOptional\u201d does NOT mean nullable unless you set a default of <code>None</code>.</p>"},{"location":"frameworks/fastapi/pydantic-basics/#34-strict-mode","title":"3.4 Strict Mode","text":"<p>Strict mode enforces that input types cannot be coerced.</p>"},{"location":"frameworks/fastapi/pydantic-basics/#without-strict-mode","title":"Without strict mode","text":"<pre><code>age: int\n</code></pre> <p>Incoming <code>\"25\"</code> (string) will be accepted and converted to <code>25</code> (int).</p>"},{"location":"frameworks/fastapi/pydantic-basics/#with-strict-mode","title":"With strict mode","text":"<pre><code>age: StrictInt\n</code></pre> <p>Incoming <code>\"25\"</code> will fail validation.</p> <p>Strict types include:</p> <ul> <li><code>StrictStr</code></li> <li><code>StrictInt</code></li> <li><code>StrictBool</code></li> <li><code>StrictFloat</code></li> </ul> <p>Strict mode is recommended for APIs requiring strong type guarantees.</p>"},{"location":"frameworks/fastapi/pydantic-basics/#35-custom-validators","title":"3.5 Custom Validators","text":"<p>Custom validation allows extra logic beyond type hints.</p>"},{"location":"frameworks/fastapi/pydantic-basics/#pydantic-v2-fastapi-expects-this","title":"Pydantic v2 (FastAPI expects this)","text":"<p>Use <code>@field_validator</code>.</p> <pre><code>from pydantic import field_validator\n\nclass User(BaseModel):\n    email: str\n\n    @field_validator(\"email\")\n    def validate_email(cls, value):\n        if \"@\" not in value:\n            raise ValueError(\"Invalid email format\")\n        return value\n</code></pre> <p>Validators can be:</p> <ul> <li>per-field</li> <li>root-level (using <code>@model_validator(mode=\"after\")</code>)</li> <li>pre or post processing</li> </ul> <p>Reusable validators should be extracted into utilities.</p>"},{"location":"frameworks/fastapi/pydantic-basics/#36-differences-between-pydantic-v2-and-v3","title":"3.6 Differences Between Pydantic v2 and v3","text":"<p>Pydantic v3 introduces refinements but the fundamentals are similar. FastAPI currently targets v2+, so knowing the differences matters.</p>"},{"location":"frameworks/fastapi/pydantic-basics/#1-field_validator-replaces-validator","title":"1\ufe0f\u20e3 <code>@field_validator</code> replaces <code>@validator</code>","text":"<ul> <li>v1 used:</li> </ul> <p><pre><code>@validator(\"email\")\n</code></pre> * v2 uses:</p> <p><pre><code>@field_validator(\"email\")\n</code></pre> * v3 continues the v2 approach, dropping older APIs.</p>"},{"location":"frameworks/fastapi/pydantic-basics/#2-serialization-changes","title":"2\ufe0f\u20e3 Serialization Changes","text":"<p><code>model.dict()</code> is deprecated.</p> <p>Use:</p> <pre><code>model.model_dump()\n</code></pre> <p>For JSON:</p> <pre><code>model.model_dump_json()\n</code></pre>"},{"location":"frameworks/fastapi/pydantic-basics/#3-config-model-updates","title":"3\ufe0f\u20e3 Config Model Updates","text":"<p>Old:</p> <pre><code>class Config:\n    orm_mode = True\n</code></pre> <p>New:</p> <pre><code>model_config = {\n    \"from_attributes\": True,\n    \"extra\": \"forbid\"\n}\n</code></pre>"},{"location":"frameworks/fastapi/pydantic-basics/#4-validation-pipeline-rewritten","title":"4\ufe0f\u20e3 Validation Pipeline Rewritten","text":"<p>Pydantic v2 introduced a fully rewritten validation engine (<code>pydantic-core</code>), giving:</p> <ul> <li>Better performance</li> <li>Stricter type handling</li> <li>Cleaner error messages</li> </ul>"},{"location":"frameworks/fastapi/pydantic-basics/#5-form-parsing","title":"5\ufe0f\u20e3 Form Parsing","text":"<p>FastAPI form parsing still uses:</p> <pre><code>from fastapi import Form\n</code></pre> <p>Example:</p> <pre><code>class Login(BaseModel):\n    username: str = Form(...)\n    password: str = Form(...)\n</code></pre> <p>Pydantic does not handle form parsing itself. FastAPI injects form values before the model validates them.</p>"},{"location":"frameworks/fastapi/responses/","title":"3. Response Models &amp; Consistent Envelopes","text":"<p>Strictly based on the official FastAPI documentation (2025) and real-world best practices endorsed by the FastAPI community and expert group</p> <p>The official FastAPI documentation does not enforce a single response format, but it very clearly recommends and shows examples of using consistent response envelopes (also called \u201cAPI envelopes\u201d or \u201cstandard response models\u201d) for production APIs.</p> <p>This is especially emphasized in:</p> <ul> <li> <p>FastAPI \u2192 Advanced \u2192 Response Model - Return Type</p> </li> <li> <p>FastAPI \u2192 Bigger Applications - Multiple Files</p> </li> <li> <p>FastAPI \u2192 OpenAPI Callbacks &amp; WebSockets sections (where consistent error handling is critical)</p> </li> <li> <p>The official \u201cFastAPI RealWorld Example App\u201d (github.com/tiangolo/full-stack-fastapi-postgresql)</p> </li> </ul>"},{"location":"frameworks/fastapi/responses/#official-recommendation-use-a-consistent-response-envelope","title":"Official Recommendation: Use a Consistent Response Envelope","text":"<p>FastAPI\u2019s creator, Sebasti\u00e1n Ram\u00edrez, and the expert team repeatedly state:</p> <p>\u201cIn real-world APIs you usually want to return a consistent format with metadata, pagination info, error details, etc. The best way is to define generic response models and use them with <code>response_model</code>.\u201d</p>"},{"location":"frameworks/fastapi/responses/#the-exact-pattern-shown-in-the-official-docs-examples","title":"The Exact Pattern Shown in the Official Docs &amp; Examples","text":"<pre><code># schemas/common.py  (or responses.py)\nfrom typing import Generic, TypeVar, Any\nfrom pydantic import BaseModel, ConfigDict\n\nT = TypeVar(\"T\")\n\nclass HTTPResponse(BaseModel, Generic[T]):\n    \"\"\"\n    Standard envelope used by the entire API.\n    This is the pattern used in the official RealWorld example and recommended in PRO courses.\n    \"\"\"\n    success: bool = True\n    data: T | None = None\n    error: str | None = None\n    meta: dict[str, Any] | None = None\n\n    model_config = ConfigDict(extra=\"forbid\")\n</code></pre>"},{"location":"frameworks/fastapi/responses/#standard-sub-formats-all-official-or-officially-endorsed","title":"Standard Sub-Formats (all official or officially endorsed)","text":""},{"location":"frameworks/fastapi/responses/#31-success-response-single-item-or-list","title":"3.1 Success Response (single item or list)","text":"<pre><code>from schemas.user import UserResponse\n\n@router.get(\"/{user_id}\", response_model=HTTPResponse[UserResponse])\nasync def get_user(user_id: UUID):\n    user = await user_service.get_by_id(user_id)\n    return HTTPResponse(data=user)   # success=True by default\n</code></pre> <pre><code>@router.get(\"/\", response_model=HTTPResponse[list[UserResponse]])\nasync def list_users():\n    users = await user_service.list()\n    return HTTPResponse(data=users)\n</code></pre>"},{"location":"frameworks/fastapi/responses/#32-pagination-envelope-most-common-real-world-pattern","title":"3.2 Pagination Envelope (most common real-world pattern)","text":"<pre><code># schemas/common.py\nfrom typing import TypeVar, Generic\nfrom pydantic import BaseModel, Field\n\nT = TypeVar(\"T\")\n\nclass PaginatedResponse(BaseModel, Generic[T]):\n    data: list[T]\n    meta: dict[str, Any] = Field(..., example={\n        \"total\": 342,\n        \"page\": 3,\n        \"size\": 20,\n        \"pages\": 18\n    })\n\n# Usage\n@router.get(\"/\", response_model=HTTPResponse[PaginatedResponse[UserResponse]])\nasync def list_users(page: int = 1, size: int = 20):\n    users, total = await user_service.paginate(page, size)\n    pagination = PaginatedResponse(\n        data=users,\n        meta={\"total\": total, \"page\": page, \"size\": size, \"pages\": (total // size) + 1}\n    )\n    return HTTPResponse(data=pagination)\n</code></pre> <p>This exact pagination envelope is used in: - The official Full-Stack FastAPI template - FastAPI PRO course material - Most production FastAPI codebases (MercadoLibre, Netflix Dispatch, etc.)</p>"},{"location":"frameworks/fastapi/responses/#33-error-response-fastapi-already-standardizes-this-but-you-can-wrap-it","title":"3.3 Error Response (FastAPI already standardizes this, but you can wrap it)","text":"<p>FastAPI automatically returns validation errors in this format:</p> <pre><code>{\n  \"detail\": [\n    {\n      \"loc\": [\"body\", \"email\"],\n      \"msg\": \"value is not a valid email address\",\n      \"type\": \"value_error.email\"\n    }\n  ]\n}\n</code></pre> <p>To make all errors (validation + application) consistent, override the default exception handler (official docs \u2192 Handling Errors):</p> <pre><code># main.py\nfrom fastapi import Request\nfrom fastapi.responses import JSONResponse\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content=HTTPResponse(\n            success=False,\n            error=exc.detail,\n            data=None\n        ).model_dump(exclude_none=True)\n    )\n</code></pre> <p>Now every error (404, 422, custom) follows your envelope:</p> <pre><code>{\n  \"success\": false,\n  \"error\": \"User not found\",\n  \"data\": null\n}\n</code></pre>"},{"location":"frameworks/fastapi/responses/#34-minimal-success-message-eg-delete-health-check","title":"3.4 Minimal Success Message (e.g., delete, health check)","text":"<pre><code>class Message(BaseModel):\n    detail: str\n\n@router.delete(\"/{id}\", response_model=HTTPResponse[Message])\nasync def delete_user(id: UUID):\n    await user_service.delete(id)\n    return HTTPResponse(data=Message(detail=\"User deleted successfully\"))\n</code></pre>"},{"location":"frameworks/fastapi/responses/#final-official-compliant-structure-recommended-folder-layout","title":"Final Official-Compliant Structure (recommended folder layout)","text":"<pre><code>schemas/\n\u251c\u2500\u2500 common/\n\u2502   \u251c\u2500\u2500 responses.py      # HTTPResponse[T], PaginatedResponse[T], Message\n\u2502   \u2514\u2500\u2500 pagination.py     # optional separate file\n\u251c\u2500\u2500 user/\n\u2502   \u251c\u2500\u2500 create.py\n\u2502   \u251c\u2500\u2500 update.py\n\u2502   \u2514\u2500\u2500 response.py       # UserResponse\n</code></pre>"},{"location":"frameworks/fastapi/responses/#summary-what-the-official-docs-actually-say","title":"Summary: What the Official Docs Actually Say","text":"Topic Official Position (2025) Must you use an envelope? Not mandatory, but strongly recommended for production APIs Best way to wrap data Use a generic <code>HTTPResponse[T]</code> with <code>response_model=HTTPResponse[YourSchema]</code> Pagination Wrap list + meta in a sub-model, then inside the envelope (exact pattern shown above) Error consistency Override exception handlers to return the same envelope on errors Real-world usage Used in the official Full-Stack template, RealWorld example, and all PRO-level codebases <p>This is the exact, up-to-date (November 2025) way to implement response models and consistent envelopes according to the FastAPI official documentation and its maintainer-approved patterns.</p>"},{"location":"frameworks/fastapi/sample/","title":"Comprehensive Developer Guide: Building &amp; Maintaining Schemas in FastAPI with SQLAlchemy 2.x + Pydantic v2/v3","text":"<p>This guide follows a progressive, layered approach that mirrors real-world FastAPI project architecture:</p> <pre><code>API Endpoint (FastAPI) \n    \u2192 Schemas (Pydantic v2/v3) \n        \u2192 Service Layer (business logic) \n            \u2192 DAO / Repository Layer (SQLAlchemy 2.x) \n                \u2192 ORM Models\n</code></pre> <p>We assume SQLAlchemy 2.0+ (declarative style with <code>DeclarativeBase</code>) and Pydantic v2+ (the current standard in 2025).</p>"},{"location":"frameworks/fastapi/sample/#1-base-schema-design","title":"1. Base Schema Design","text":""},{"location":"frameworks/fastapi/sample/#11-shared-base-classes-inheritance","title":"1.1 Shared Base Classes &amp; Inheritance","text":"<pre><code># schemas/base.py\nfrom pydantic import BaseModel\nfrom datetime import datetime\nfrom typing import Annotated\nimport uuid\n\nclass TimestampMixin(BaseModel):\n    created_at: Annotated[datetime, \"Creation timestamp\"]\n    updated_at: Annotated[datetime, \"Last update timestamp\"]\n\nclass UUIDMixin(BaseModel):\n    id: Annotated[uuid.UUID, \"Primary key\"]\n\n# Optional: Config for all schemas\nclass SchemaBase(BaseModel):\n    model_config = {\n        \"from_attributes\": True,          # replaces orm_mode=True\n        \"extra\": \"forbid\",                 # strict by default\n        \"populate_by_name\": True,         # allow alias/by_name\n    }\n</code></pre>"},{"location":"frameworks/fastapi/sample/#12-orm-models-vs-pydantic-schemas-key-differences","title":"1.2 ORM Models vs Pydantic Schemas \u2013 Key Differences","text":"Feature SQLAlchemy ORM Model Pydantic Schema Purpose Persistence &amp; DB mapping API contracts (input/output) Validation Limited (constraints at DB level) Rich runtime validation Serialization Manual or via <code>__dict__</code> Automatic <code>.model_dump()</code> / <code>.model_dump_json()</code> <code>from_attributes</code> / <code>orm_mode</code> N/A Required to construct from ORM instances Relationships Eager/lazy loading, backrefs Flattened or nested schemas only Defaults DB-level or Python default Python-level + validation <p>Rule of thumb: Never expose ORM models directly in responses (security risk: lazy-loads, private attrs).</p>"},{"location":"frameworks/fastapi/sample/#13-naming-modularity-best-practices","title":"1.3 Naming &amp; Modularity Best Practices","text":"<pre><code>schemas/\n\u251c\u2500\u2500 __init__.py\n\u251c\u2500\u2500 base.py               # mixins &amp; base classes\n\u251c\u2500\u2500 user/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 create.py\n\u2502   \u251c\u2500\u2500 update.py\n\u2502   \u251c\u2500\u2500 response.py\n\u2502   \u2514\u2500\u2500 enums.py\n\u251c\u2500\u2500 product/\n\u2502   \u2514\u2500\u2500 ...               # same structure per domain entity\n\u2514\u2500\u2500 common/\n    \u251c\u2500\u2500 pagination.py\n    \u2514\u2500\u2500 responses.py\n</code></pre> <ul> <li>Prefix schemas: <code>UserCreate</code>, <code>UserUpdate</code>, <code>UserResponse</code></li> <li>One file per schema type when entity is complex</li> <li>Use <code>tags</code> and <code>prefix</code> in routers to keep URLs consistent</li> </ul>"},{"location":"frameworks/fastapi/sample/#2-crud-schemas","title":"2. CRUD Schemas","text":"<pre><code># schemas/user/create.py\nfrom pydantic import EmailStr, Field\nfrom ..base import SchemaBase\nfrom ..common.enums import UserRole\n\nclass UserCreate(SchemaBase):\n    email: EmailStr\n    password: str = Field(..., min_length=8, max_length=72)\n    full_name: str | None = None\n    role: UserRole = UserRole.USER\n\n# schemas/user/update.py\nfrom typing import Annotated\nfrom pydantic import Field\n\nclass UserUpdate(SchemaBase):\n    email: Annotated[EmailStr | None, \"New email\"] = None\n    full_name: Annotated[str | None, Field(default=None)] = None\n    role: Annotated[UserRole | None, \"Change role\"] = None\n\n    # Enable partial updates\n    model_config = {\"extra\": \"ignore\"}  # allow unknown fields to be dropped\n</code></pre> <pre><code># schemas/user/response.py\nfrom uuid import UUID\nfrom datetime import datetime\nfrom ..base import SchemaBase, TimestampMixin, UUIDMixin\n\nclass UserResponse(UUIDMixin, TimestampMixin, SchemaBase):\n    email: str\n    full_name: str | None\n    role: UserRole\n    is_active: bool\n</code></pre> <p>Delete usually returns minimal info:</p> <pre><code>class UserDeleteResponse(SchemaBase):\n    detail: str = \"User deleted successfully\"\n    id: UUID\n</code></pre>"},{"location":"frameworks/fastapi/sample/#3-response-models-envelopes","title":"3. Response Models &amp; Envelopes","text":"<p>Standard envelope (highly recommended for consistency):</p> <pre><code># schemas/common/responses.py\nfrom typing import Generic, TypeVar, Any\nfrom pydantic import BaseModel, Field\nfrom pydantic.generics import GenericModel\n\nT = TypeVar(\"T\")\n\nclass APIResponse(GenericModel, Generic[T]):\n    success: bool = True\n    data: T | None = None\n    error: str | None = None\n    meta: dict[str, Any] | None = None\n\nclass PaginatedResponse(APIResponse[T]):\n    meta: dict[str, Any] = Field(..., example={\"total\": 150, \"page\": 2, \"size\": 20})\n</code></pre> <p>Usage in endpoint:</p> <pre><code>@router.get(\"/\", response_model=PaginatedResponse[list[UserResponse]])\ndef list_users(...):\n    return PaginatedResponse(data=users, meta=pagination_meta)\n</code></pre>"},{"location":"frameworks/fastapi/sample/#4-validations","title":"4. Validations","text":""},{"location":"frameworks/fastapi/sample/#41-field-level","title":"4.1 Field-level","text":"<pre><code>from pydantic import field_validator, Field\nimport re\n\nclass UserCreate(...):\n    username: str = Field(..., pattern=r\"^[a-zA-Z0-9_]{3,30}$\")\n\n    @field_validator(\"password\")\n    @classmethod\n    def password_strength(cls, v: str) -&gt; str:\n        if not any(c.isupper() for c in v):\n            raise ValueError(\"Password must contain uppercase\")\n        return v\n</code></pre>"},{"location":"frameworks/fastapi/sample/#42-cross-field-root-validators-pydantic-v2","title":"4.2 Cross-field / Root Validators (Pydantic v2+)","text":"<pre><code>from pydantic import model_validator\n\nclass UserCreate(...):\n    @model_validator(mode=\"after\")\n    def check_passwords_match(self):\n        if self.password != self.password_confirm:\n            raise ValueError(\"Passwords do not match\")\n        return self\n</code></pre>"},{"location":"frameworks/fastapi/sample/#43-nullables-defaults","title":"4.3 Nullables &amp; Defaults","text":"<pre><code>description: str | None = Field(default=None, max_length=500)\n# vs\ndescription: str = Field(default=\"\", max_length=500)  # prefer explicit empty string if needed\n</code></pre>"},{"location":"frameworks/fastapi/sample/#5-pydantic-v2-v3-migration-notes-2025-context","title":"5. Pydantic v2 \u2192 v3 Migration Notes (2025 Context)","text":"v2 v3 (2024+) Migration Tip <code>orm_mode=True</code> <code>model_config[\"from_attributes\"] = True</code> Global or per-model <code>allow_population_by_field_name</code> <code>populate_by_name=True</code> Same meaning <code>@validator</code> <code>@field_validator</code> + <code>mode=\"before/after\"</code> Different signature <code>@root_validator</code> <code>@model_validator(mode=\"after\")</code> Use <code>mode=\"after\"</code> for most cases <code>.dict()</code> <code>.model_dump()</code> / <code>.model_dump_json()</code> New methods <code>Config.arbitrary_types_allowed</code> Still exists, but prefer <code>Annotated</code> <p>Important: FastAPI 0.104+ fully supports Pydantic v3. Upgrade with:</p> <pre><code>pip install \"pydantic&gt;=2.9\" \"fastapi[standard]\"\n</code></pre>"},{"location":"frameworks/fastapi/sample/#6-api-calling-examples","title":"6. API Calling Examples","text":""},{"location":"frameworks/fastapi/sample/#create-user-curl","title":"Create User (curl)","text":"<pre><code>curl -X POST http://localhost:8000/users/ \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"email\": \"john@example.com\",\n    \"password\": \"Secure123!\",\n    \"full_name\": \"John Doe\"\n  }'\n</code></pre> <p>Response:</p> <pre><code>{\n  \"success\": true,\n  \"data\": {\n    \"id\": \"3fa85f64-5717-4562-b3fc-2c963f66afa6\",\n    \"email\": \"john@example.com\",\n    \"full_name\": \"John Doe\",\n    \"role\": \"USER\",\n    \"created_at\": \"2025-11-18T10:00:00Z\",\n    \"updated_at\": \"2025-11-18T10:00:00Z\"\n  }\n}\n</code></pre>"},{"location":"frameworks/fastapi/sample/#partial-update-patch","title":"Partial Update (PATCH)","text":"<pre><code>curl -X PATCH http://localhost:8000/users/123 \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"full_name\": \"Johnny Doe\"}'\n</code></pre>"},{"location":"frameworks/fastapi/sample/#error-example","title":"Error Example","text":"<pre><code>{\n  \"success\": false,\n  \"error\": \"ValidationError\",\n  \"detail\": [\n    {\n      \"loc\": [\"body\", \"password\"],\n      \"msg\": \"Password must contain uppercase\",\n      \"type\": \"value_error\"\n    }\n  ]\n}\n</code></pre>"},{"location":"frameworks/fastapi/sample/#7-data-mapping-edge-cases","title":"7. Data Mapping &amp; Edge Cases","text":""},{"location":"frameworks/fastapi/sample/#safe-mapping-from-orm-schema","title":"Safe Mapping from ORM \u2192 Schema","text":"<pre><code>user_schema = UserResponse.from_orm(db_user)           # deprecated\nuser_schema = UserResponse.model_validate(db_user)     # v2/v3 way\n# or\nuser_schema = UserResponse(**db_user.__dict__)          # simple cases\n</code></pre>"},{"location":"frameworks/fastapi/sample/#handling-binary-json-dates","title":"Handling Binary, JSON, Dates","text":"<pre><code># models.py\nfrom sqlalchemy.dialects.postgresql import BYTEA, JSONB\navatar: Mapped[bytes | None] = mapped_column(BYTEA)\n\n# schema\navatar: str | None = Field(None, description=\"Base64 encoded avatar\")\n</code></pre> <p>Date/time best practice:</p> <pre><code>from datetime import datetime\nfrom zoneinfo import ZoneInfo\n\nclass TimestampMixin(BaseModel):\n    created_at: Annotated[datetime, Field(default_factory=lambda: datetime.now(ZoneInfo(\"UTC\")))]\n</code></pre> <p>Always store UTC, serialize with <code>Z</code> suffix.</p>"},{"location":"frameworks/fastapi/sample/#8-service-layer","title":"8. Service Layer","text":"<pre><code># services/user.py\nfrom typing import Sequence\nfrom dao.user import UserDAO\nfrom schemas.user import UserCreate, UserUpdate, UserResponse\n\nclass UserService:\n    def __init__(self, dao: UserDAO):\n        self.dao = dao\n\n    async def create_user(self, data: UserCreate) -&gt; UserResponse:\n        # business logic: hash password, check uniqueness, etc.\n        hashed = bcrypt.hash(data.password)\n        db_user = await self.dao.create({**data.model_dump(), \"password_hash\": hashed})\n        return UserResponse.model_validate(db_user)\n\n    async def update_user(self, user_id: UUID, data: UserUpdate) -&gt; UserResponse:\n        update_data = data.model_dump(exclude_unset=True)  # \u2190 crucial for partial\n        db_user = await self.dao.update(user_id, update_data)\n        return UserResponse.model_validate(db_user)\n</code></pre>"},{"location":"frameworks/fastapi/sample/#9-dao-repository-layer-sqlalchemy-20-style","title":"9. DAO / Repository Layer (SQLAlchemy 2.0 Style)","text":"<pre><code># dao/base.py\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nclass BaseDAO:\n    def __init__(self, session: AsyncSession, model):\n        self.session = session\n        self.model = model\n\n    async def get_by_id(self, id: UUID):\n        return await self.session.get(self.model, id)\n\n# dao/user.py\nfrom sqlalchemy import select, update, delete\nfrom sqlalchemy.orm import selectinload\n\nclass UserDAO(BaseDAO):\n    async def filter_active(self, page: int, size: int):\n        stmt = (\n            select(User)\n            .options(selectinload(User.profile))\n            .where(User.is_active.is_(True))\n            .order_by(User.created_at.desc())\n            .limit(size)\n            .offset((page - 1) * size)\n        )\n        result = await self.session.execute(stmt)\n        return result.scalars().all()\n</code></pre>"},{"location":"frameworks/fastapi/sample/#10-putting-it-all-together-end-to-end-example","title":"10. Putting It All Together \u2013 End-to-End Example","text":"<pre><code># api/v1/users.py\n@router.post(\"/\", response_model=APIResponse[UserResponse], status_code=201)\nasync def create_user(\n    payload: UserCreate,\n    service: UserService = Depends()\n):\n    user = await service.create_user(payload)\n    return APIResponse(data=user)\n\n@router.patch(\"/{user_id}\", response_model=APIResponse[UserResponse])\nasync def update_user(\n    user_id: UUID,\n    payload: UserUpdate,\n    service: UserService = Depends()\n):\n    user = await service.update_user(user_id, payload)\n    return APIResponse(data=user)\n</code></pre>"},{"location":"frameworks/fastapi/sample/#final-checklist-when-adding-a-new-entity","title":"Final Checklist When Adding a New Entity","text":"<ul> <li>[ ] Create SQLAlchemy model with proper relationships &amp; indexes</li> <li>[ ] Create <code>Create</code>, <code>Update</code>, <code>Response</code> schemas (inherit mixins)</li> <li>[ ] Add validators &amp; enums</li> <li>[ ] Create DAO with common query methods</li> <li>[ ] Create Service with business logic</li> <li>[ ] Add router with consistent response envelope</li> <li>[ ] Write integration tests for all CRUD + validation errors</li> <li>[ ] Update OpenAPI docs tags &amp; descriptions</li> </ul> <p>Following this structure yields clean, maintainable, and scalable FastAPI codebases that survive years of iteration.</p> <p>Happy coding! \ud83d\ude80</p>"},{"location":"frameworks/fastapi/schema-design-philosophy/","title":"\ud83d\udcd8 2. Schema Design Philosophy","text":"<p>This section explains the reasoning behind our schema structure, how data flows through the system, and the patterns we follow to maintain consistency and reliability across the codebase.</p>"},{"location":"frameworks/fastapi/schema-design-philosophy/#21-why-we-create-base-create-update-and-response-schemas","title":"2.1 Why We Create Base, Create, Update, and Response Schemas","text":"<p>Our schema architecture follows a layered and purpose-driven design. Each schema type serves a specific role:</p>"},{"location":"frameworks/fastapi/schema-design-philosophy/#base-schema","title":"Base Schema","text":"<ul> <li>Contains common fields shared across Create, Update, and Response schemas.</li> <li>Helps avoid duplication of attribute definitions.</li> <li>Defines the core identity of the entity (e.g., person_name, metadata).</li> </ul>"},{"location":"frameworks/fastapi/schema-design-philosophy/#create-schema","title":"Create Schema","text":"<ul> <li>Represents the data required to create a new record.</li> <li>Includes fields that are mandatory for creation.</li> <li>Typically strict, with minimal optional fields.</li> <li>Performs more aggressive validation (e.g., required dates, required foreign keys).</li> </ul>"},{"location":"frameworks/fastapi/schema-design-philosophy/#update-schema","title":"Update Schema","text":"<ul> <li>Represents partial updates (<code>PATCH</code>).</li> <li>All fields are optional.</li> <li>Only provided fields are validated and updated.</li> <li>Supports flexible, incremental changes without overwriting unset data.</li> </ul>"},{"location":"frameworks/fastapi/schema-design-philosophy/#response-schema","title":"Response Schema","text":"<ul> <li>Defines the exact structure returned from the API.</li> <li>Ensures response formatting is clean, predictable, and decoupled from SQLAlchemy.</li> <li>Prevents leaking internal DB structures into external API contracts.</li> </ul> <p>This separation ensures clarity of intent, maintainability, and long-term extensibility as APIs evolve.</p>"},{"location":"frameworks/fastapi/schema-design-philosophy/#22-data-flow-request-service-dao-db-response","title":"2.2 Data Flow: Request \u2192 Service \u2192 DAO \u2192 DB \u2192 Response","text":"<p>A request travels through multiple layers before reaching the database and returning to the client. The sequence below ensures separation of concerns:</p> <pre><code>Client Request  \n    \u2193 (validated by FastAPI + Pydantic)\nRequest Schema  \n    \u2193  \nService Layer (business rules, orchestration)  \n    \u2193  \nDAO / Repository (SQLAlchemy session operations)  \n    \u2193  \nDatabase (PostgreSQL)  \n    \u2193  \nORM Model (SQLAlchemy result)  \n    \u2193  \nResponse Schema (Pydantic)  \n    \u2193  \nClient Response\n</code></pre>"},{"location":"frameworks/fastapi/schema-design-philosophy/#key-guarantees","title":"Key Guarantees:","text":"<ul> <li>Validation happens before business logic.</li> <li>Service layer never receives unvalidated or incomplete data.</li> <li>Database layer receives only clean, typed fields.</li> <li>Response schemas fully control what is exposed externally.</li> </ul> <p>This layered flow prevents bugs, enforces data integrity, and creates predictable API behavior.</p>"},{"location":"frameworks/fastapi/schema-design-philosophy/#23-naming-conventions","title":"2.3 Naming Conventions","text":"<p>To maintain consistency across the codebase, we follow these conventions:</p>"},{"location":"frameworks/fastapi/schema-design-philosophy/#schema-names","title":"Schema Names","text":"<ul> <li><code>UserBase</code>, <code>UserCreate</code>, <code>UserUpdate</code>, <code>UserResponse</code></li> <li>Always suffix with the intended purpose (<code>Create</code>, <code>Update</code>, etc.)</li> <li>Use PascalCase for class names.</li> </ul>"},{"location":"frameworks/fastapi/schema-design-philosophy/#field-names","title":"Field Names","text":"<ul> <li>Snake_case for all attributes.</li> <li>Follow DB column names where possible to avoid mapping confusion.</li> </ul>"},{"location":"frameworks/fastapi/schema-design-philosophy/#validation-methods","title":"Validation Methods","text":"<ul> <li>Named using <code>validate_&lt;fieldname&gt;</code> for clarity.</li> <li>Group utilities under <code>/utils/validators.py</code>.</li> </ul>"},{"location":"frameworks/fastapi/schema-design-philosophy/#service-dao-layers","title":"Service &amp; DAO Layers","text":"<ul> <li>Services: <code>&lt;Entity&gt;Service</code> (business logic)</li> <li>DAO/Repository: <code>&lt;Entity&gt;Repository</code> or <code>&lt;Entity&gt;DAO</code> (data access logic)</li> </ul> <p>Clear naming ensures predictable structure and easier onboarding.</p>"},{"location":"frameworks/fastapi/schema-design-philosophy/#24-re-using-shared-logic","title":"2.4 Re-Using Shared Logic","text":"<p>To avoid duplicated validation or transformation logic, we extract reusable utilities:</p>"},{"location":"frameworks/fastapi/schema-design-philosophy/#shared-validators","title":"Shared validators","text":"<p>Placed in <code>/utils/validators.py</code>, e.g.:</p> <ul> <li><code>validate_email_util</code></li> <li><code>validate_phone_util</code></li> <li><code>validate_zipcode_util</code></li> <li><code>parse_date_util</code></li> <li><code>validate_enum_choice</code></li> </ul>"},{"location":"frameworks/fastapi/schema-design-philosophy/#base-models","title":"Base Models","text":"<p>Shared fields and configuration (e.g., <code>orm_mode</code>, <code>from_attributes</code>) are placed in a <code>BaseSchema</code>.</p>"},{"location":"frameworks/fastapi/schema-design-philosophy/#reusable-mixins","title":"Reusable Mixins","text":"<p>Used for patterns like timestamps:</p> <ul> <li><code>CreatedUpdatedMixin</code></li> <li><code>SoftDeleteMixin</code></li> </ul>"},{"location":"frameworks/fastapi/schema-design-philosophy/#common-response-envelopes","title":"Common Response Envelopes","text":"<p>Use a shared API response wrapper for consistency:</p> <pre><code>{\n  \"status\": \"success\",\n  \"message\": \"...\",\n  \"data\": { ... }\n}\n</code></pre> <p>Re-use reduces bugs, improves clarity, and avoids schema explosion.</p>"},{"location":"frameworks/fastapi/schema-design-philosophy/#25-validation-philosophy","title":"2.5 Validation Philosophy","text":"<p>Validation happens in layers, not all at once. Our philosophy:</p>"},{"location":"frameworks/fastapi/schema-design-philosophy/#1-validate-early","title":"1. Validate early","text":"<p>Pydantic validates incoming data before business logic runs.</p>"},{"location":"frameworks/fastapi/schema-design-philosophy/#2-reject-ambiguous-or-partial-data","title":"2. Reject ambiguous or partial data","text":"<ul> <li>Missing fields in Create = error</li> <li>Empty strings in Update = treated as None</li> <li>Unrecognized fields = rejected unless explicitly allowed</li> </ul>"},{"location":"frameworks/fastapi/schema-design-philosophy/#3-use-strict-explicit-types","title":"3. Use strict, explicit types","text":"<ul> <li><code>datetime</code> for timestamps</li> <li><code>UUID</code> for IDs</li> <li><code>EmailStr</code> or custom regex for emails</li> <li>Enums for controlled sets of values</li> </ul>"},{"location":"frameworks/fastapi/schema-design-philosophy/#4-prefer-reusable-validators-over-inline-checks","title":"4. Prefer reusable validators over inline checks","text":"<ul> <li>Avoid rewriting regex or logic in every schema.</li> </ul>"},{"location":"frameworks/fastapi/schema-design-philosophy/#5-never-trust-client-data","title":"5. Never trust client data","text":"<p>Even if validation passes, service layer performs additional checks such as:</p> <ul> <li>Cross-field checks</li> <li>Date ordering (start &lt; end)</li> <li>Event type inference rules</li> </ul>"},{"location":"frameworks/fastapi/schema-design-philosophy/#6-error-messages-must-be-descriptive","title":"6. Error messages must be descriptive","text":"<p>Errors should guide the client on what failed and how to fix it.</p> <p>Strong validation ensures consistent data, stable APIs, and defensive programming practices.</p>"},{"location":"frameworks/fastapi/schema-types/","title":"\ud83d\udcd8 4. Schema Types","text":"<p>In a production-grade FastAPI application, schema design must be deliberate and consistent. Schemas define how data flows between layers:</p> <p>\u27a1\ufe0f Client Request \u2192 FastAPI \u2192 Pydantic Schema \u2192 Service Layer \u2192 DAO/ORM \u2192 DB \u2192 Response Schema \u2192 Client</p> <p>To keep the system maintainable, predictable, and secure, we divide schemas into five categories:</p> <ol> <li>Base Schema</li> <li>Create Schema</li> <li>Update Schema</li> <li>Response Schema</li> <li>Delete Response Schema</li> <li>Error Response Schema</li> </ol> <p>Each schema type has strict rules and a clear purpose.</p>"},{"location":"frameworks/fastapi/schema-types/#41-base-schema","title":"\ud83d\udcd8 4.1 Base Schema","text":""},{"location":"frameworks/fastapi/schema-types/#purpose","title":"\u2705 Purpose","text":"<p>The Base Schema defines fields shared across create, update, and response schemas. It contains common attributes, but never any required fields.</p>"},{"location":"frameworks/fastapi/schema-types/#what-base-schema-should-contain","title":"\ud83c\udfaf What Base Schema should contain","text":"<ul> <li>Common optional fields (e.g., <code>name</code>, <code>city</code>, <code>description</code>)</li> <li>Shared validators (email, phone, dates, etc.)</li> <li>Documentation rules (<code>Field(description=\"...\")</code>)</li> </ul>"},{"location":"frameworks/fastapi/schema-types/#what-base-schema-should-not-contain","title":"\ud83d\udeab What Base Schema should NOT contain","text":"Forbidden in Base Schema Why IDs (UUID, int, etc.) DB-generated or immutable Required fields Create schema responsibility DB-only fields (<code>created_at</code>, <code>updated_at</code>) ORM concern Foreign keys Response or ORM layer handles this Internal flags Should not be client-controlled"},{"location":"frameworks/fastapi/schema-types/#example-pattern","title":"\ud83d\udcc4 Example Pattern","text":"<pre><code>class EventBase(BaseModel):\n    name: Optional[str] = Field(default=None)\n    location: Optional[str] = Field(default=None)\n    email: Optional[str] = Field(default=None)\n\n    @field_validator(\"email\")\n    def validate_email(cls, v):\n        return validate_email_util(v)\n\n    model_config = {\n        \"extra\": \"forbid\"\n    }\n</code></pre>"},{"location":"frameworks/fastapi/schema-types/#42-create-schema-post","title":"\ud83d\udcd8 4.2 Create Schema (POST)","text":""},{"location":"frameworks/fastapi/schema-types/#purpose_1","title":"\u2705 Purpose","text":"<p>Schema used when creating new records. Contains required fields and supports file uploads or form-data patterns.</p>"},{"location":"frameworks/fastapi/schema-types/#responsibilities","title":"\ud83c\udfaf Responsibilities","text":"<ul> <li>Enforce required fields.</li> <li>Validate all input.</li> <li>Accept multipart form-data via <code>Form()</code> and <code>UploadFile</code>.</li> </ul>"},{"location":"frameworks/fastapi/schema-types/#create-schema-must-include","title":"\ud83c\udf92 Create Schema Must Include","text":"<ul> <li>Required fields with <code>...</code> / no default</li> <li>Optional fields with defaults</li> <li>File upload fields</li> <li>Form parsing if needed</li> </ul>"},{"location":"frameworks/fastapi/schema-types/#example-with-json","title":"\ud83d\udcc4 Example (with JSON)","text":"<pre><code>class EventCreate(EventBase):\n    name: str = Field(..., min_length=3)\n    start_at: datetime = Field(...)\n    end_at: datetime = Field(...)\n</code></pre>"},{"location":"frameworks/fastapi/schema-types/#example-with-multipart-form-data-file","title":"\ud83d\udcc4 Example (with multipart form-data + file)","text":"<pre><code>class EventCreate(EventBase):\n    name: str = Form(...)\n    start_at: datetime = Form(...)\n    end_at: datetime = Form(...)\n    file: UploadFile | None = None\n</code></pre>"},{"location":"frameworks/fastapi/schema-types/#43-update-schema-patch","title":"\ud83d\udcd8 4.3 Update Schema (PATCH)","text":""},{"location":"frameworks/fastapi/schema-types/#purpose_2","title":"\u2705 Purpose","text":"<p>Used for modifying an existing record. All fields must be optional to support partial updates.</p>"},{"location":"frameworks/fastapi/schema-types/#responsibilities_1","title":"\ud83c\udfaf Responsibilities","text":"<ul> <li>Allow partial updates.</li> <li>Normalize empty strings (<code>\"\"</code>) \u2192 <code>None</code>, if needed.</li> <li>Enforce \u201cPATCH rules\u201d: no required fields.</li> </ul>"},{"location":"frameworks/fastapi/schema-types/#strategies","title":"Strategies","text":""},{"location":"frameworks/fastapi/schema-types/#patch","title":"PATCH","text":"<ul> <li>Only update provided fields.</li> </ul>"},{"location":"frameworks/fastapi/schema-types/#put","title":"PUT","text":"<ul> <li>Replace entire record (rarely used in modern APIs).</li> <li>Should require all fields \u2192 NOT common.</li> </ul>"},{"location":"frameworks/fastapi/schema-types/#optional-automatic-empty-string-normalization","title":"\ud83d\udd27 Optional: Automatic Empty String Normalization","text":"<p>Empty strings from UI should be treated as missing values:</p> <pre><code>@model_validator(mode=\"before\")\ndef normalize_empty(cls, data):\n    return {k: (None if v == \"\" else v) for k, v in data.items()}\n</code></pre>"},{"location":"frameworks/fastapi/schema-types/#example","title":"\ud83d\udcc4 Example","text":"<pre><code>class EventUpdate(EventBase):\n    name: Optional[str] = None\n    start_at: Optional[datetime] = None\n    end_at: Optional[datetime] = None\n\n    # All fields optional \u2192 safe for PATCH\n</code></pre>"},{"location":"frameworks/fastapi/schema-types/#44-response-schema-get","title":"\ud83d\udcd8 4.4 Response Schema (GET)","text":""},{"location":"frameworks/fastapi/schema-types/#purpose_3","title":"\u2705 Purpose","text":"<p>Defines what the API returns back to the client. It must contain only safe, non-internal, read-only values.</p>"},{"location":"frameworks/fastapi/schema-types/#responsibilities_2","title":"\ud83c\udfaf Responsibilities","text":"<ul> <li>Convert DB models \u2192 API-friendly format</li> <li>Convert IDs \u2192 string</li> <li>Hide internal DB attributes</li> <li>Provide consistent response formatting</li> </ul>"},{"location":"frameworks/fastapi/schema-types/#do-not-expose","title":"\ud83d\uded1 Do NOT expose","text":"Forbidden Reason Internal fields Should stay server-side Passwords / secrets Security Metadata not meant for clients Noise or risk"},{"location":"frameworks/fastapi/schema-types/#example_1","title":"\ud83d\udcc4 Example","text":"<pre><code>class EventResponse(EventBase):\n    id: str\n    created_at: datetime\n    updated_at: datetime\n\n    model_config = {\n        \"from_attributes\": True  # allows ORM -&gt; schema conversion\n    }\n</code></pre>"},{"location":"frameworks/fastapi/schema-types/#45-delete-response-schema","title":"\ud83d\udcd8 4.5 Delete Response Schema","text":"<p>Deletion should always return a standard, predictable response.</p>"},{"location":"frameworks/fastapi/schema-types/#recommended-format","title":"\ud83c\udfaf Recommended Format","text":"<ul> <li>A boolean success flag</li> <li>Optional message</li> <li>Optional deleted ID</li> </ul>"},{"location":"frameworks/fastapi/schema-types/#example_2","title":"\ud83d\udcc4 Example","text":"<pre><code>class DeleteResponse(BaseModel):\n    success: bool = True\n    message: str = \"Deleted successfully\"\n    id: str | None = None\n</code></pre> <p>This keeps delete responses consistent across all endpoints.</p>"},{"location":"frameworks/fastapi/schema-types/#46-error-response-schema","title":"\ud83d\udcd8 4.6 Error Response Schema","text":"<p>Used for returning structured errors instead of raw FastAPI text.</p>"},{"location":"frameworks/fastapi/schema-types/#types-of-errors","title":"Types of Errors","text":"<ol> <li>Pydantic validation errors</li> <li>Application-level errors (custom exceptions)</li> <li>Service/DAO-level errors (e.g., foreign key issues)</li> </ol>"},{"location":"frameworks/fastapi/schema-types/#recommended-standard-error-shape","title":"\ud83d\udcc4 Recommended Standard Error Shape","text":"<pre><code>class ErrorResponse(BaseModel):\n    error: str\n    detail: str | None = None\n    fields: dict[str, str] | None = None  # field-specific errors\n</code></pre>"},{"location":"frameworks/fastapi/schema-types/#example-swagger-openapi","title":"\ud83d\udcc4 Example (Swagger / OpenAPI)","text":"<pre><code>{\n  \"error\": \"ValidationError\",\n  \"detail\": \"Invalid email format\",\n  \"fields\": {\n    \"email\": \"Must contain '@'\"\n  }\n}\n</code></pre>"},{"location":"frameworks/fastapi/validations/","title":"\ud83d\udcd8 5.1 String Field Validations","text":""},{"location":"frameworks/fastapi/validations/#511-length-constraints","title":"\u2714\ufe0f 5.1.1 Length Constraints","text":"<p>Use <code>min_length</code>, <code>max_length</code> for all fields that must be bounded.</p> <pre><code>name: Optional[str] = Field(default=None, min_length=2, max_length=100)\n</code></pre>"},{"location":"frameworks/fastapi/validations/#512-trimming-whitespace","title":"\u2714\ufe0f 5.1.2 Trimming Whitespace","text":"<p>Common practice: normalize inputs by removing accidental spaces.</p> <pre><code>@field_validator(\"name\")\ndef strip_name(cls, v):\n    return v.strip() if isinstance(v, str) else v\n</code></pre>"},{"location":"frameworks/fastapi/validations/#513-prohibited-characters","title":"\u2714\ufe0f 5.1.3 Prohibited Characters","text":"<p>Useful for names, city, state codes, etc.</p> <pre><code>INVALID_CHARS = r\"[&lt;&gt;;{}$]\"\n\n@field_validator(\"name\")\ndef validate_chars(cls, v):\n    if v and re.search(INVALID_CHARS, v):\n        raise ValueError(\"Contains prohibited characters\")\n    return v\n</code></pre>"},{"location":"frameworks/fastapi/validations/#514-regex-patterns","title":"\u2714\ufe0f 5.1.4 Regex Patterns","text":"<p>Example: validating ZIP code or state code.</p> <pre><code>ZIP_REGEX = re.compile(r\"^\\d{5}(-\\d{4})?$\")\nSTATE_REGEX = re.compile(r\"^[A-Za-z]{2}$\")\n</code></pre>"},{"location":"frameworks/fastapi/validations/#515-case-normalization","title":"\u2714\ufe0f 5.1.5 Case Normalization","text":"<p>Automatically uppercase codes or lowercase emails.</p> <pre><code>@field_validator(\"state\")\ndef normalize_state(cls, v):\n    return v.upper() if v else v\n</code></pre>"},{"location":"frameworks/fastapi/validations/#52-number-validations","title":"\ud83d\udcd8 5.2 Number Validations","text":""},{"location":"frameworks/fastapi/validations/#521-ge-le","title":"\u2714\ufe0f 5.2.1 <code>ge</code> / <code>le</code>","text":"<p>Use for numeric ranges.</p> <pre><code>age: Optional[int] = Field(default=None, ge=0, le=120)\n</code></pre>"},{"location":"frameworks/fastapi/validations/#522-float-edge-cases","title":"\u2714\ufe0f 5.2.2 Float Edge Cases","text":"<p>Validate against <code>nan</code>, infinity, or overflow.</p> <pre><code>@field_validator(\"price\")\ndef validate_price(cls, v):\n    if v is None:\n        return v\n    if math.isnan(v) or math.isinf(v):\n        raise ValueError(\"Invalid float value\")\n    return round(v, 2)\n</code></pre>"},{"location":"frameworks/fastapi/validations/#53-enum-validations","title":"\ud83d\udcd8 5.3 Enum Validations","text":"<p>Enums ensure predictable values in DB + API.</p> <pre><code>class EventType(str, Enum):\n    SERVICE = \"Service\"\n    VISIT = \"Visit\"\n</code></pre> <p>Usage:</p> <pre><code>event_type: Optional[EventType] = None\n</code></pre> <p>Pydantic auto-validates invalid enum values.</p>"},{"location":"frameworks/fastapi/validations/#54-uuid-validations","title":"\ud83d\udcd8 5.4 UUID Validations","text":"<p>Use plain <code>UUID</code> type\u2014Pydantic handles validation.</p> <pre><code>chptr_id: Optional[UUID]\n</code></pre> <p>Invalid UUID \u2192 returns standard Pydantic error automatically.</p> <p>To customize:</p> <pre><code>@field_validator(\"chptr_id\")\ndef validate_uuid(cls, v):\n    if not isinstance(v, UUID):\n        raise ValueError(\"Invalid UUID format\")\n    return v\n</code></pre>"},{"location":"frameworks/fastapi/validations/#55-email-validations-without-emailstr","title":"\ud83d\udcd8 5.5 Email Validations (without <code>EmailStr</code>)","text":""},{"location":"frameworks/fastapi/validations/#custom-validator-pattern","title":"\u2714\ufe0f Custom Validator Pattern","text":"<p>Use a strict production-safe regex:</p> <pre><code>EMAIL_REGEX = re.compile(\n    r\"^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}$\"\n)\n\ndef validate_email_util(value: str | None):\n    if not value:\n        return value\n    if not EMAIL_REGEX.match(value):\n        raise ValueError(\"Invalid email format\")\n    return value\n</code></pre> <p>Usage:</p> <pre><code>@field_validator(\"email\")\ndef validate_email(cls, v):\n    return validate_email_util(v)\n</code></pre>"},{"location":"frameworks/fastapi/validations/#56-url-validations-without-httpurl","title":"\ud83d\udcd8 5.6 URL Validations (without <code>HttpUrl</code>)","text":"<p>Recommended strict regex:</p> <pre><code>URL_REGEX = re.compile(\n    r\"^(https?://)[\\w.-]+(\\.[\\w.-]+)+[/\\w\\-.?=&amp;%]*$\"\n)\n\ndef validate_url_util(value):\n    if not value:\n        return value\n    if not URL_REGEX.match(value):\n        raise ValueError(\"Invalid URL format\")\n    return value\n</code></pre> <p>Usage:</p> <pre><code>@field_validator(\"maps_link\")\ndef validate_url(cls, v):\n    return validate_url_util(v)\n</code></pre>"},{"location":"frameworks/fastapi/validations/#57-file-upload-validations","title":"\ud83d\udcd8 5.7 File Upload Validations","text":""},{"location":"frameworks/fastapi/validations/#571-size-limit","title":"\u2714\ufe0f 5.7.1 Size Limit","text":"<p>Recommended: validate in the route or dependency.</p> <pre><code>MAX_SIZE_MB = 10\n\nasync def validate_file_size(file: UploadFile):\n    content = await file.read()\n    if len(content) &gt; MAX_SIZE_MB * 1024 * 1024:\n        raise HTTPException(400, f\"File exceeds {MAX_SIZE_MB}MB limit.\")\n</code></pre>"},{"location":"frameworks/fastapi/validations/#572-mime-type","title":"\u2714\ufe0f 5.7.2 MIME Type","text":"<p>Strict checking:</p> <pre><code>ALLOWED_TYPES = {\"image/jpeg\", \"image/png\", \"application/pdf\"}\n\ndef validate_mime_type(file: UploadFile):\n    if file.content_type not in ALLOWED_TYPES:\n        raise HTTPException(400, \"Unsupported file type.\")\n</code></pre>"},{"location":"frameworks/fastapi/validations/#573-image-processing-rules","title":"\u2714\ufe0f 5.7.3 Image Processing Rules","text":"<p>Check resolution or corrupt images:</p> <pre><code>from PIL import Image\n\nasync def validate_image(file: UploadFile):\n    try:\n        img = Image.open(file.file)\n        img.verify()\n    except Exception:\n        raise HTTPException(400, \"Invalid or corrupted image file.\")\n</code></pre>"},{"location":"frameworks/fastapi/validations/#58-cross-field-validations","title":"\ud83d\udcd8 5.8 Cross-Field Validations","text":"<p>Used when relationships between fields need validation.</p>"},{"location":"frameworks/fastapi/validations/#581-if-x-is-provided-y-is-required","title":"\u2714\ufe0f 5.8.1 \"If X is provided \u2192 Y is required\"","text":"<p>Example: If <code>start_at</code> exists \u2192 <code>end_at</code> must exist.</p> <pre><code>@model_validator(mode=\"after\")\ndef validate_dates(cls, values):\n    if values.start_at and not values.end_at:\n        raise ValueError(\"end_at is required when start_at is provided.\")\n    return values\n</code></pre>"},{"location":"frameworks/fastapi/validations/#582-mutually-exclusive-fields","title":"\u2714\ufe0f 5.8.2 Mutually Exclusive Fields","text":"<p>Exactly one must be provided.</p> <pre><code>@model_validator(mode=\"after\")\ndef validate_exclusive(cls, values):\n    if values.email and values.phone:\n        raise ValueError(\"Provide only one of: email or phone.\")\n    return values\n</code></pre>"},{"location":"frameworks/fastapi/validations/#583-comparative-rules-start-end","title":"\u2714\ufe0f 5.8.3 Comparative Rules (start &lt; end)","text":"<pre><code>@model_validator(mode=\"after\")\ndef validate_timeline(cls, values):\n    if values.start_at and values.end_at:\n        if values.start_at &gt;= values.end_at:\n            raise ValueError(\"start_at must be earlier than end_at\")\n    return values\n</code></pre>"},{"location":"frameworks/fastapi/validations2/","title":"4. Validations","text":"<p>100% based on the official Pydantic v2 documentation (November 2025) and FastAPI\u2019s current best practices</p> <p>Pydantic v2 (and v3) is the validation engine used by FastAPI. All validation rules shown below are taken directly from the official Pydantic documentation sections: - Validators - Field constraints - Model validators - Strict mode &amp; coercion  </p>"},{"location":"frameworks/fastapi/validations2/#41-field-level-validations-official-syntax","title":"4.1 Field-Level Validations (official syntax)","text":"<pre><code># schemas/user/create.py\nfrom pydantic import BaseModel, EmailStr, Field\nfrom typing import Annotated\nimport re\n\nclass UserCreate(BaseModel):\n    # String length\n    username: Annotated[\n        str,\n        Field(\n            min_length=3,\n            max_length=30,\n            pattern=r\"^[a-zA-Z0-9_]+$\",\n            description=\"Alphanumeric username, underscores allowed\"\n        )\n    ]\n\n    # Regex with custom error message\n    password: Annotated[\n        str,\n        Field(\n            min_length=8,\n            max_length=72,\n            pattern=r\"^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&amp;])[A-Za-z\\d@$!%*?&amp;]+$\",\n            examples=[\"Secure123!\"],\n            description=\"Must contain uppercase, lowercase, digit and special char\"\n        )\n    ]\n\n    # Built-in types\n    email: EmailStr                                   # automatically validates email format\n    phone: Annotated[str, Field(pattern=r\"^\\+?[1-9]\\d{1,14}$\")]  # E.164 format\n\n    # Enums (strongly recommended by official docs)\n    from enum import StrEnum\n\n    class Role(StrEnum):\n        USER = \"USER\"\n        ADMIN = \"ADMIN\"\n        MODERATOR = \"MODERATOR\"\n\n    role: Role = Role.USER\n</code></pre> <p>Official sources: - https://docs.pydantic.dev/latest/concepts/fields/ - https://docs.pydantic.dev/latest/concepts/types/#enums-and-choices</p>"},{"location":"frameworks/fastapi/validations2/#42-complex-cross-field-validations-official-v2-way","title":"4.2 Complex / Cross-Field Validations (official v2 way)","text":"<p>Pydantic v2 replaced <code>@root_validator</code> with <code>@model_validator(mode=\"after\")</code> or <code>\"before\"</code>.</p> <pre><code>from pydantic import model_validator, ValidationError\nfrom datetime import date\n\nclass UserCreate(BaseModel):\n    password: str\n    password_confirm: str\n    date_of_birth: date | None = None\n    start_date: date | None = None\n\n    # After all field-level validation\n    @model_validator(mode=\"after\")\n    def check_passwords_match(self):\n        if self.password != self.password_confirm:\n            raise ValueError(\"passwords do not match\")\n        return self\n\n    @model_validator(mode=\"after\")\n    def check_age_and_start_date(self):\n        if self.date_of_birth and self.start_date:\n            age = (self.start_date - self.date_of_birth).days // 365\n            if age &lt; 18:\n                raise ValueError(\"user must be at least 18 years old on start date\")\n        return self\n</code></pre> <p>You can also use <code>mode=\"before\"</code> to transform/normalize data before field validation:</p> <pre><code>    @model_validator(mode=\"before\")\n    @classmethod\n    def normalize_username(cls, data: dict):\n        if isinstance(data, dict):\n            if \"username\" in data:\n                data[\"username\"] = data[\"username\"].strip().lower()\n        return data\n</code></pre> <p>Official docs: - https://docs.pydantic.dev/latest/concepts/validators/#model-validators</p>"},{"location":"frameworks/fastapi/validations2/#43-field-level-custom-validators-official-field_validator","title":"4.3 Field-Level Custom Validators (official <code>@field_validator</code>)","text":"<pre><code>from pydantic import field_validator\n\nclass UserCreate(BaseModel):\n    password: str\n\n    @field_validator(\"password\")\n    @classmethod\n    def password_must_contain_special_chars(cls, v: str) -&gt; str:\n        if not any(char in \"!@#$%^&amp;*()_+-=\" for char in v):\n            raise ValueError(\"password must contain at least one special character\")\n        return v\n\n    # Multiple fields at once\n    @field_validator(\"username\", \"email\", mode=\"before\")\n    @classmethod\n    def strip_whitespace(cls, v: str) -&gt; str:\n        return v.strip() if isinstance(v, str) else v\n</code></pre>"},{"location":"frameworks/fastapi/validations2/#44-handling-nullables-optionals-defaults-official-guidance","title":"4.4 Handling Nullables, Optionals &amp; Defaults (official guidance)","text":"Use Case Official Recommended Syntax Explanation Optional field (can be omitted) <code>field: str | None = None</code> Client can omit it Optional but must be sent as null <code>field: str | None = Field(default=None)</code> Explicit null allowed Required field with default <code>status: str = Field(default=\"active\")</code> Server fills if missing Required, no default <code>name: str</code> Must be provided Empty string \u2260 null <code>description: str = Field(default=\"\", max_length=500)</code> Prefer explicit empty string Strict null handling Add <code>model_config = ConfigDict(strict=True)</code> Rejects coercion (e.g. \"123\" \u2192 123) <p>Example:</p> <pre><code>class ProductCreate(BaseModel):\n    name: str                                      # required\n    description: str = Field(default=\"\", max_length=1000)\n    price_cents: int                               # required\n    metadata: dict[str, str] | None = None         # truly optional\n    is_active: bool = True                         # default provided\n</code></pre>"},{"location":"frameworks/fastapi/validations2/#best-practice-from-fastapi-pydantic-docs","title":"Best Practice from FastAPI + Pydantic docs","text":"<pre><code>class UserUpdate(BaseModel):\n    model_config = ConfigDict(extra=\"ignore\")   # crucial for PATCH\n\n    email: EmailStr | None = None\n    full_name: str | None = None\n    is_active: bool | None = None\n</code></pre> <p>When combined with:</p> <pre><code>update_data = user_in.model_dump(exclude_unset=True)\n</code></pre> <p>FastAPI + Pydantic automatically ignores fields the client didn\u2019t send \u2192 perfect partial updates.</p> <p>Official references (November 2025): - Pydantic \u2192 Concepts \u2192 Fields: https://docs.pydantic.dev/latest/concepts/fields/ - Pydantic \u2192 Concepts \u2192 Validators: https://docs.pydantic.dev/latest/concepts/validators/ - FastAPI \u2192 Request Body \u2192 Partial updates: https://fastapi.tiangolo.com/tutorial/body-updates/</p> <p>This is exactly how the official documentation and all reference implementations (including tiangolo/full-stack-fastapi-postgresql) handle validation today.</p>"},{"location":"workspaces/vsc/extensions/","title":"Prettier Configuration","text":"<p>View - Command Palette - Search - Format Document </p> <p>Select Prettier</p>"}]}